%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% LaTeX book template                           %%
%% Author:  Amber Jain (http://amberj.devio.us/) %%
%% License: ISC license                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source: http://en.wikibooks.org/wiki/LaTeX/Hyperlinks %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{lscape}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage[ruled]{algorithm2e}

\lstset{% general command to set parameter(s)
	basicstyle=\small, % print whole listing small
	numbers=left,
	keywordstyle=\color{black}\bfseries,
	% underlined bold black keywords
	identifierstyle=, % nothing happens
	stringstyle=\ttfamily} % typewriter type for strings
\lstset{language=Java} 
\captionsetup{tableposition=top,figureposition=bottom,font=small}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 'dedication' environment: To add a dedication paragraph at the start of book %
% Source: http://www.tug.org/pipermail/texhax/2010-June/015184.html            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{dedication}
{
   \cleardoublepage
   \thispagestyle{empty}
   \vspace*{\stretch{1}}
   \hfill\begin{minipage}[t]{0.66\textwidth}
   \raggedright
}
{
   \end{minipage}
   \vspace*{\stretch{3}}
   \clearpage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter quote at the start of chapter        %
% Source: http://tex.stackexchange.com/a/53380 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\@chapapp}{}% Not necessary...
\newenvironment{chapquote}[2][2em]
  {\setlength{\@tempdima}{#1}%
   \def\chapquote@author{#2}%
   \parshape 1 \@tempdima \dimexpr\textwidth-2\@tempdima\relax%
   \itshape}
  {\par\normalfont\hfill--\ \chapquote@author\hspace*{\@tempdima}\par\bigskip}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% First page of book which contains 'stuff' like: %
%  - Book title, subtitle                         %
%  - Book author name                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Book's title and subtitle
\title{\Huge \textbf{Gestione di un sistema di book-crossing:\\ \textit{\textbf{The WalkingBooks}}} \\ \huge \textit{\textbf{Documentazione progettuale}} \\ \bigskip \huge Progetto del corso di Informatica IIIB \\ \huge A.A. 2018/2019}
% Author
\author{\textsc{Paganessi Andrea} \\ \textsc{Piffari Michele} \\ \textsc{Villa Stefano}}


\begin{document}

\frontmatter
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Auto-generated table of contents, list of figures and list of tables %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\listoffigures
\listoftables

\mainmatter

%%%%%%%%%%%%%%%%
% NEW PART! %
%%%%%%%%%%%%%%%%
\part{Iterazione 0}

%%%%%%%%%%%%%%%%
% NEW CHAPTER! %
%%%%%%%%%%%%%%%%
\chapter{Requisiti e specifiche}
\section{Requisiti utente}
\input{Capitolo_Sezioni/RequisitiUtente}
\chapter{Use cases}
\section{Analisi testuale dei casi d'uso}
\input{Capitolo_Sezioni/AnalisiCasiUso}
\section{Use Case Diagram}
\input{Capitolo_Sezioni/UseCases}
\newpage
\section{Funzionalità richieste}
\input{Capitolo_Sezioni/FunzionalitàRichieste}
\section{Stati del libro}
La starup si impone l'obbiettivo di andare a gestire lo scambio di libri all'interno della rete di book-crossing: come visto all'interno dei diversi use-cases, ogni libro, nel corso della propria vita all'interno della community, passa di mano in mano, attraversando diverse zone.
A questo movimento fisico, corrisponde anche un continuo cambio di stato da parte del libro stesse: possiamo riassumere con una \textit{"Finite State Machine"} il percorso che un generico libro segue durante la sua vita.

{\LARGE INSERIRE PICCOLO SCHEMA DEGLI STATI}


Riassumendo gli stati di un libro, possono essere:
\begin{itemize}
	\item Out of the network
	\item Available
	\item Under reading
	\item Released
	\item Reserved
	\item Traveling
\end{itemize}

\chapter{Architettura}
\section{Deployment diagram}
\begin{figure}[h]
	\includegraphics[width=\textwidth]{Immagini/Deployment_Diagram}
	\caption{Deployment Diagram}
	\label{fig:Deployment Diagram}
\end{figure}
\section{Architecture Envisioning}
\begin{figure}[h]
	\includegraphics[width=\textwidth]{Immagini/Architecture_Envisoring}
	\caption{Architecture Envisioning}
	\label{fig:ArchitectureEnvisoring}
\end{figure}
\noindent
In figura ~\ref{fig:Deployment Diagram} e ~\ref{fig:ArchitectureEnvisoring} sono mostrati il Deployment Diagram e l'Architecture Envisioning del sistema progettato per lo sviluppo dell’applicazione di Book Crossing. Si può osservare che si tratta di un’architettura \textbf{\textit{Three Tiers}}:
\begin{enumerate}
	\item A sinistra si individua il client, ovvero il dispositivo Android con il quale è possibile interfacciarsi. Al suo interno quindi si può osservare la presenza di un componente relativo all’interfaccia grafica e uno relativo alla gestione delle richieste per invio e ricezione di dati con il server;
	\item Nella parte centrale individuiamo gli altri due layer dell’architettura: server EC2 e Database Relazionale RDS. il fatto di utilizzare Amazon Web Services consente di avere questi due elementi a bordo di un unico strato.
\end{enumerate}
\noindent
Per quanto riguarda la comunicazione tra i vari layer si sfruttano protocolli e librerie fornite sempre dall'ambiente Amazon Web Services. Nel caso della comunicazione tra smartphone e server EC2 si sfrutta Amazon SDK(nota con link), mentre per interfacciarsi con il Database RDS si sfrutta il connettore JDBC.
\part{Iterazione 1}
\chapter{Architettura}
\section{Architettura software}
\begin{figure}[h]
	\includegraphics[width=\textwidth]{Immagini/Architettura_Software}
	\caption{Architettura Software}
	\label{fig:ArchitetturaSoftware}
\end{figure}
\newpage
Nella figura ~\ref{fig:ArchitetturaSoftware} è mostrata l'architettura software modellizzata attraverso una rete di Petri. Innanzitutto si può già osservare chè è stata definita seguendo il modello architetturale MVC:
\begin{itemize}
	\item A monte è prevista una parte riservata all'interfaccia grafica, attraverso la quale sarà possibile inviare e ricevere informazioni dal server applicativo. Si vede, infatti, che è prevista una comunicazione bidirezionale tra dispositivo Android e Server.
	\item Al centro sono rappresentate tutte le richieste a cui è in grado di rispondere. Queste, quindi, saranno funzioni implementate lato Server.
	\item Infine, è prevista una banca dati persistente, in questo caso un database relazione, al quale il Server Applicativo accede sia per operazioni di lettura che di scrittura, sempre con lo scopo di far fronte alle richieste provenienti a monte.
\end{itemize}
Si può quindi constatare che non si trattano di strati tra loro indipendenti, poichè il flusso dei dati li coinvolge tutti.
\section{Logical view}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\textwidth]{Immagini/Logical_View_part1}
	\caption{Logical view}
	\label{fig:LogicalView1}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\textwidth]{Immagini/Logical_View_part2}
	\caption{Logical view}
	\label{fig:LogicalView2}
\end{figure}
\noindent
In figura ~\ref{fig:LogicalView1} e ~\ref{fig:LogicalView2} è mostrata la Logical View del sistema progettato. Si può osservare che segue il modello definito attraverso il pattern archietteturale Model View Controller/Presenter, dal momento che vengono individuati tre strati, ciascuno dei quali con le seguenti caratteristiche:
\begin{itemize}
	\item \textbf{Subsystem \textit{"GUI”:}} Rappresenta l’interfaccia grafica con la quale l’applicazione si presenterà. Ciascun componente fa riferimento ad una azione che può essere svolta attraverso lo smartphone, come l’accesso alla rete di Book Crossing(Login) o registrazione di un  libro. Questi componenti saranno quindi allocati direttamente sul dispositivo mobile. 
	\item \textbf{Subsystem \textit{"Request Manager”:}} Ha il compito di gestire le richieste provenienti da ciascun componente descritto nel subsystem \textit{GUI”}. Al suo interno sono indicati i componenti attraverso i quali si risponde alle chiamate provenienti dal client. Questo quindi descrive i componenti che saranno individuati sul server presente all’interno dell’architettura.
	\item \textbf{Subsystem \textit{"Data Manager":}} ”: Rappresenta la comunicazione con il Database. Sono quindi indicati i componenti con i quali il sistema si interfaccerà con la banca dati dell’architettura.
\end{itemize}
Il modello architetturale MVC è stato poi applicato anche successivamente per la progettazione delle componenti previste per ciascun elemento dell'architettura.

\newpage
\section{Parte algoritmica: \textit{reservation handler}}
Le gestione delle prenotazioni dei libri è una delle parte innovative introdotte dalla start up: questo servizio mira a sfruttare la flessibilità della community di sharing, basata sull'ideale di open-source, per comunque offrire un seervizio mirato ed attento alle necessità del lettore.
Ogni utente, purchè sia registrato all'interno del servizio di Book-sharing, può prenotare un determinato libro che si trova nello stato "Under reading".

Andiamo ad evidenziare gli attori coinvolti in questa operazione:
\begin{itemize}
	\item \textbf{\underline{Lettore} [L]:} esso rappresenta l'utente, registrato nella community, che possiede il libro oggetto della prenotazione. Indichiamo con:
	\begin{itemize}
		\item \textbf{{\LARGE $r_{L}$}:} raggio d'azione del lettore;
		\item \textbf{{\LARGE $ z_{0} $}:} zona di residenza (espressa come coordinate puntuali).
	\end{itemize}
	\item \textbf{\underline{Prenotanti} [$ P_{i}$ con $i=1,...,N $]:} rappresentano l'insieme degli utenti, tutti interessati ad uno specifico libro in possesso dell'utente \textbf{L}.
	Nello specifico l'indice \textit{i-esimo} indica l'ordine temporale con cui sono giunte le prenotazioni per lo specifico libro.
	Oltre a questa informazione, ogni utente, rappresentando un generico utente della community, avrà fornito, al momento della registrazione, le seguenti informazioni:
	\begin{itemize}
		\item \textbf{{\LARGE $r^{i}_{P}$} con $i=1,...,N $:} raggio d'azione del lettore;
		\item \textbf{{\LARGE $z^{i}_{P}$} con $i=1,...,N $:} zona di residenza.
	\end{itemize}

	L'algoritmo può essere scomposto in due macro-blocchi:
	\begin{itemize}
		\item \textbf{Step 0:} questo fase viene realizzata nel momento in cui il sistema inizia ad analizzare tutti gli utenti che hanno effettuato una prenotazione per un determinato libro che si trova nello stato di "Under reading".
		
		Tutti gli N prenotanti \textit{$ P_{i} $} vengono ordinati in base alla distanza dal lettore \textit{L}, indipendentemente da quello che è l'ordine temporale con cui è stata effettuata la prenotazione: la quantità di cui si terrà conto sarà quindi
		{\LARGE \begin{equation}
			|z^{p}_{i}-z_{0}|
		\end{equation}}
		Questo ordinamento corrisponde quindi sostanzialmente a creare una \textit{priority queue} in cui si va ad assegnare una maggiore priorità all'utente la cui zona di residenza è più vicina a quella del lettore in possesso del libro.
		\item \textbf{Step 1:} in questo macro-blocco andiamo effettivamente ad applicare l'algoritmo \textit{smart} per poter soddisfare, nella maniera migliore, le esigenze di ogni utente della community.
		
		L'idea di base è che, se lettore e prenotante hanno possibilità di incontrarsi, ovvero se i loro raggi d'azione si sovrappongono, essi potranno accordarsi direttamente sul luogo dello scambio, rendendo \textit{"safety"} il passaggio del libro.
		Nel caso in cui invece, i due utenti interessati, non abbiano la possibilità di trovare un luogo comune in cui potersi scambiare il libro direttamente, si avrà che, la rete di users appartenenti alla community farà da tramite, per portare il libro \textit{"coast-to-coast"}.
		Quindi, tramite un semplice pseudo-codice, possiamo scrivere il nostro algoritmo come
	
		\begin{algorithm}[H]
			\SetAlgoLined
			\KwData{Users and their informations}
			\KwResult{Optimum path from reader to reserver}
			Step 0 (intilization)\;
			\eIf{Distanza <= 0}{
				Trova un punto d'incontro nell'unione delle delle area;
				Notifica gli utenti di dove potersi scambiare direttamente il libro
			}{
				Crea la rete di utenti che faranno da tramite tra lettore e prenotante
				Ricerca del cammino ottimo (il libro si muoverà \textit{hand-to-hand})
			}
			\caption{Algoritmo di gestione della prenotazione}
		\end{algorithm}
		
		Nello specifico il calcolo della distanza avverrà tramite la funzionalità \textit{VerificaPuntoIncontro(Lettore, Prenotante)} (TODO: inseire funzione effettiva), la quale andrà a verificare che:
		
		{\LARGE \begin{equation}
			|z^{p}_{i}-z_{0}|-r_{0}-r_{i}<=0
		\end{equation}}
		
		ovvero che i raggi d'azione si sovrappongano.
		
		Nel caso in cui i due utenti non abbiano un possibili punto d'incontro (Distanza$>= 0 $), dobbiamo selezionare gli utenti tramite il quale il libro in questione potrà viaggiare: l'idea base è quindi quella di costruirsi un'area circolare di centro pari alla metà della congiungente del punto $ z_{0} $ (zona di residenza lettore) e $ z^{p}_{i} $ (zona di residenza prenotante).
		Andremo poi a selezionare tutti gli utenti che si trovano all'interno di questa circoscrizione.
		In passi sequenziali, possiamo scrivere:
		
		\begin{algorithm}[H]
			\SetAlgoLined
			\KwData{Zona di residenza e raggio d'azione di utente lettore e prenotante}
			\KwResult{Elenco di utenti attraverso cui il libro dovrà spostarsi \textit{hand-to-hand}}
			
			Calcolo distanza media tra zona di residenza lettore ($ z_{0} $) e zona residenza prenotante ($z_{i}^P $)\;
			
			Il raggio della circoscrizione di utenti coinvolti sarà pari alla distanza
			\[ \bar{Z} = \dfrac{1}{2}\bullet(Distanza(z_{0},z_{i}^P)) \]
			\For{All user $ z_{i}^U $ in the community}{
			\If{$ (Distanza(z_{0},z_{i}^U)) <= \bar{Z} $ oppure $ (Distanza(z_{i}^P,z_{i}^U)) <= \bar{Z} $  }{
				
				Seleziono l'utente $ z_{i}^U $ e lo inserisco nella lista (\textit{HandToHandUsers}) dei possibili utenti che potrebbero partecipare attivamente al prestito.
			}
			}
			Creiamo il collegamento tra gli users della lista \textit{HandToHandUsers} il cui raggio d'azione si sovrappone\:
			\caption{Creazione del percorso tra lettore e prenotante}
		\end{algorithm}
		
		
		\begin{itemize}
			\item Calcolo centro del bacino circolare di users:
			\begin{equation}
				Z = \dfrac{1}{2} |z^{p}_{i}-z_{0}|
			\end{equation}
			\item Tra tutti gli utenti registrati nella community, seleziono tutti quelli, tali per cui, chiamata $z^{u}_{i}$, la zona di residenza, vale
			\begin{equation}
				|z^{u}_{i}-z_{0}| < Z
			\end{equation}
			Si tratta quindi di tutti gli users inclusi nella circonferenza tra lettore e prenotante.
		\end{itemize}				
	\end{itemize}
\end{itemize}
\end{document}
